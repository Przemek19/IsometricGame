IsometricGame.Map = class {
  constructor(GameObject, size = 64, offset = {x: 0, y: 0, z: 0}) {
    this.tiles = [];
    this.objects = [];
    this.lastTileID = -1;
    this.lastObjectID = -1;
    this.offset = offset;
    this.size = size;
    this.extraTiles = [];
    this.GameObject = GameObject;
    this.lowestPoint = undefined;
    this.highestPoint = undefined;
  }
  async load(file) {
    const texturesToLoad = [];
    for (let i in IsometricGame.Map.defaultTiles) {
      const tileData = IsometricGame.Map.defaultTiles[i];
      if (tileData.src) texturesToLoad.push(tileData.src);
      if (tileData.animation) {
        for (let ii in tileData.animation.textures) {
          texturesToLoad.push(tileData.animation.textures[ii]);
        }
      }
    }
    for (let i in IsometricGame.Map.defaultObjects) {
      const objectData = IsometricGame.Map.defaultObjects[i];
      if (objectData.src) texturesToLoad.push(objectData.src);
      if (objectData.animation) {
        for (let ii in objectData.animation.textures) {
          texturesToLoad.push(objectData.animation.textures[ii]);
        }
      }
    }
    await this.GameObject.loadTextures(texturesToLoad);
    const mapData = await (await fetch(file.search('http') !== -1 ? file : `src/maps/${file}.json`)).json();
    const tiles = mapData.tiles;
    for (let i in tiles) {
      const tile = tiles[i];
      this.createTile(tile.tid, tile.x + this.offset.x, tile.y + this.offset.y, tile.z + this.offset.z);
    }
  }
  createTile(tid, x, y, z) {
    this.lastTileID += 1;
    if (!this.lowestPoint) {
      this.lowestPoint = { x, y, z };
    } else {
      if (x < this.lowestPoint.x) this.lowestPoint.x = x;
      if (y < this.lowestPoint.y) this.lowestPoint.x = y;
      if (z < this.lowestPoint.z) this.lowestPoint.x = z;
    }
    if (!this.highestPoint) {
      this.highestPoint = { x, y, z };
    } else {
      if (x > this.highestPoint.x) { this.highestPoint.x = x; }
      if (y > this.highestPoint.y) { this.highestPoint.y = y; }
      if (z > this.highestPoint.z) { this.highestPoint.z = z; }
    }
    return this.tiles[this.tiles.push({ id: this.lastTileID, tid, x, y, z }) - 1];
  }
  createObject(oid, x, y, z) {
    this.lastObjectID += 1;
    if (!this.lowestPoint) {
      this.lowestPoint = { x, y, z };
    } else {
      if (x < this.lowestPoint.x) this.lowestPoint.x = x;
      if (y < this.lowestPoint.y) this.lowestPoint.x = y;
      if (z < this.lowestPoint.z) this.lowestPoint.x = z;
    }
    if (!this.highestPoint) {
      this.highestPoint = { x, y, z };
    } else {
      if (x > this.highestPoint.x) { this.highestPoint.x = x; }
      if (y > this.highestPoint.y) { this.highestPoint.y = y; }
      if (z > this.highestPoint.z) { this.highestPoint.z = z; }
    }
    return this.objects[this.objects.push({ id: this.lastObjectID, oid, x, y, z }) - 1]; 
  }
  download() {
    const newTiles = [...this.tiles];
    newTiles.map(tile => delete tile.id);
    const dataString = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify({
      name: 'AutoGenerated',
      version: '1.0.0',
      author: 'AutoGenerated',
      tiles: newTiles,
      // TODO: Add objects
    }));

    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute('href', dataString);
    downloadAnchorNode.setAttribute('download', `map.json`);
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
  }

  drawTile(tile, cameraSize) {
    let tileData;
    if (IsometricGame.Map.defaultTiles[tile.tid]) { // TODO: Dodać własne elementy od twórcy mapy
      tileData = IsometricGame.Map.defaultTiles[tile.tid];
    }

    const screenPosition = this.GameObject.getScreenPositionFromTile(tile.x, tile.y, tile.z, cameraSize);

    let src = tileData.src;
    if (tileData.animation) {
      const t = Date.now() % tileData.animation.duration * tileData.animation.textures.length;
      for (let ii in tileData.animation.textures) {
        ii = Number(ii);
        const interval = (ii + 1) * tileData.animation.duration;
        if (t <= interval && t > interval - tileData.animation.duration) {
          src = tileData.animation.textures[ii];
          break;
        }
      }
    }

    this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, this.size * this.GameObject.camera.size, this.size * this.GameObject.camera.size);
    if (this.GameObject.devmode) {
      this.GameObject.drawText(`(${tile.x}x;${tile.y}y;${tile.z}z)`, screenPosition.x + this.size * 0.25 * this.GameObject.camera.size, screenPosition.y + this.size * 0.25 * this.GameObject.camera.size, `${this.size * this.GameObject.camera.size / 12}px Arial`, '#fffa');
    }
  }

  drawObject(object, cameraSize) {
    let objectData;
    if (IsometricGame.Map.defaultObjects[object.oid]) { // TODO: Dodać własne elementy od twórcy mapy
      objectData = IsometricGame.Map.defaultObjects[object.oid];
    }
    //const screenPosition = this.GameObject.getScreenPositionFromTile(object.x - objectData.xSize - (objectData.xSize > 1 ? 1 : 0), object.y - objectData.ySize, object.z + objectData.zSize - 1, cameraSize);
    cameraSize /= 2;
    const width = 2 * cameraSize + (cameraSize * (objectData.xSize - 1)) + cameraSize * (objectData.ySize - 1);
    const height = (Math.max(objectData.xSize, objectData.ySize) - 1) * cameraSize + cameraSize + objectData.zSize * cameraSize;

    const screenPosition = this.GameObject.getScreenPositionFromTile(
      object.x,
      object.y,
      object.z,
      cameraSize * 2
    );

    const maxSize = Math.max(objectData.xSize, objectData.ySize);

    screenPosition.x = screenPosition.x - width + Math.floor(objectData.ySize / 2) * cameraSize + cameraSize * 2;
    screenPosition.y = screenPosition.y - height + cameraSize;

    let src = objectData.src;
    if (objectData.animation) {
      const t = Date.now() % objectData.animation.duration * objectData.animation.textures.length;
      for (let ii in objectData.animation.textures) {
        ii = Number(ii);
        const interval = (ii + 1) * objectData.animation.duration;
        if (t <= interval && t > interval - objectData.animation.duration) {
          src = objectData.animation.textures[ii];
          break;
        }
      }
    }


    //screenPosition.y -= height;

    //console.log(`${width};${height}`);
    this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, width, height);
  }

  getTileCursorOn(mX, mY, z = 0) {
    if (!mX || !mY) return false;
    const screenCenterX = this.GameObject.canvas.width / 2;
    const screenCenterY = this.GameObject.canvas.height / 2;
    mX = (mX - screenCenterX);
    mY = (mY - screenCenterY) * 2 - (this.size / 2 * this.GameObject.camera.size);
    
    //const gameTileSize = Math.sqrt(Math.pow(this.size / 4, 2) + Math.pow(this.size / 2, 2));
    const gameX = Math.round((mY + mX + this.GameObject.camera.x * this.size * this.GameObject.camera.size) / (this.size * this.GameObject.camera.size)) + 1 + z;
    const gameY = Math.round((mY - mX + this.GameObject.camera.y * this.size * this.GameObject.camera.size) / (this.size * this.GameObject.camera.size)) + 1 + z;

    const tileElements = [];
    let lowestZ = undefined;
    let highestZ = undefined;
    for (let tileIndex in this.tiles) {
      const tile = this.tiles[tileIndex];
      if (!tileElements[tile.x]) tileElements[tile.x] = [];
      if (!tileElements[tile.x][tile.y]) tileElements[tile.x][tile.y] = [];
      tileElements[tile.x][tile.y][tile.z] = tile;
      if (typeof lowestZ === 'undefined') lowestZ = tile.z;
      if (typeof highestZ === 'undefined') highestZ = tile.z;
      if (lowestZ > tile.z) lowestZ = tile.z;
      if (highestZ < tile.z) highestZ = tile.z;
    }
    //console.log(lowestZ)
    for (let lz = highestZ; lz >= lowestZ; lz -= 1) {
      if (tileElements[gameX + lz] && tileElements[gameX + lz][gameY + lz] && tileElements[gameX + lz][gameY + lz][lz]) {
        z = lz;
        break;
      }
    }
  
    this.drawTile({ tid: -1, x: gameX + z, y: gameY + z, z: z }, this.size * this.GameObject.camera.size);

    //console.log(`${gameX};${gameY}`);
    return {
      x: gameX,
      y: gameY,
      z: z
    };
  }

  draw(options = {}) {
    const realRenderDistance = this.GameObject.renderDistance * 2 + 1;
    const cameraX = Math.floor(this.GameObject.camera.x);
    const cameraY = Math.floor(this.GameObject.camera.y);

    const tileElements = [];
    for (let tileIndex in this.tiles) {
      const tile = this.tiles[tileIndex];
      if (!tileElements[tile.x]) tileElements[tile.x] = [];
      if (!tileElements[tile.x][tile.y]) tileElements[tile.x][tile.y] = [];
      tileElements[tile.x][tile.y][tile.z] = tile;
    }
    const objectElements = [];
    for (let objectIndex in this.objects) {
      const object = this.objects[objectIndex];
      if (!objectElements[object.x]) objectElements[object.x] = [];
      if (!objectElements[object.x][object.y]) objectElements[object.x][object.y] = [];
      if (!objectElements[object.x][object.y][object.z]) objectElements[object.x][object.y][object.z] = [];
      objectElements[object.x][object.y][object.z].push(object);
    }

    for (let layer = 0; layer < realRenderDistance * 2 - 1; layer += 1) {
      const halfLayer = layer / 2;
      const halfLayerPlusCameraXMinusRenderDistance = halfLayer + cameraX - realRenderDistance;
      const halfLayerPlusCameraY = halfLayer + cameraY;
      const cameraSize = this.size * this.GameObject.camera.size;
      if (layer % 2 == 0) { // Dłuższy
        //console.log('D');
        for (let i = 0; i < realRenderDistance; i += 1) {
          const x = halfLayerPlusCameraXMinusRenderDistance + 1 + i;
          const y = halfLayerPlusCameraY - i;
          //console.log(`${x};${y}`);
          if (tileElements[x] && tileElements[x][y]) {
            for (let z = this.lowestPoint.z; z <= this.highestPoint.z; z += 1) {
              if (tileElements[x][y][z]) this.drawTile(tileElements[x][y][z], cameraSize);
            }
          }
          //if (objectElements[x]) console.log(objectElements[x]);
          //console.log(1)
          if (objectElements[x] && objectElements[x][y]) {
            for (let z = this.lowestPoint.z; z <= this.highestPoint.z; z += 1) {
              if (objectElements[x][y][z]) {  
                for (let i in objectElements[x][y][z]) {
                  this.drawObject(objectElements[x][y][z][i], cameraSize);
                }
              }
            }
          }
        }
      } else { // Krótszy
        //console.log('K');
        for (let i = 0; i < realRenderDistance - 1; i += 1) {
          const x = halfLayerPlusCameraXMinusRenderDistance + 1.5 + i;
          const y = halfLayerPlusCameraY - .5 - i;
          //console.log(`${x};${y}`);
          if (tileElements[x] && tileElements[x][y]) {
            for (let z = this.lowestPoint.z; z <= this.highestPoint.z; z += 1) {
              if (tileElements[x][y][z]) this.drawTile(tileElements[x][y][z], cameraSize);
            }
          }
          if (objectElements[x] && objectElements[x][y]) {
            for (let z = this.lowestPoint.z; z <= this.highestPoint.z; z += 1) {
              if (objectElements[x][y][z]) {  
                for (let i in objectElements[x][y][z]) {
                  this.drawObject(objectElements[x][y][z][i], cameraSize);
                }
              }
            }
          }
        }  
      }
    }
  }

  draw2() {
    const elements = [ ...this.tiles, ...this.objects ];
    const cameraRealY = -this.GameObject.camera.y * 4;
    const cameraRealX = -this.GameObject.camera.x * 2;
    //console.log(cameraRealY)
    let fromY = Math.round(cameraRealY / (this.size * this.GameObject.camera.size)) - this.GameObject.renderDistance;
    let offsetY = 0;
    if (fromY < 0) {
      offsetY = -fromY;
      fromY = 0;
    }
    let toY = Math.round(cameraRealY / (this.size * this.GameObject.camera.size)) + this.GameObject.renderDistance + offsetY;

    let fromX = Math.round(cameraRealX / (this.size * this.GameObject.camera.size)) - this.GameObject.renderDistance;
    let offsetX = 0;
    if (fromX < 0) {
      offsetX = -fromX;
      fromX = 0;
    }

    let toX = Math.round(cameraRealX / (this.size * this.GameObject.camera.size)) + this.GameObject.renderDistance + offsetX;
    console.log(`${fromX}:${fromY} - ${toX}:${toY}`);

    for (let y = fromY; y <= toY ; y += 1) {
      for (let x = fromX; x <= y ; x += 1) {
        //console.log(`${- x};${x}`);
        for (let rZ = this.lowestPoint.z; rZ <= this.highestPoint.z; rZ += 1) {
          const rX = y - x - offsetX;
          const rY = x - offsetY;
          for (let eID in this.tiles) {
            const tile = this.tiles[eID];
            if (Math.round(tile.x) == rX && Math.round(tile.y) == rY && Math.round(tile.z) == rZ) {
              // TILE

              let tileData;
              if (IsometricGame.Map.defaultTiles[tile.tid]) { // TODO: Dodać własne elementy od twórcy mapy
                tileData = IsometricGame.Map.defaultTiles[tile.tid];
              }

              const screenPosition = this.GameObject.getScreenPositionFromTile(tile.x, tile.y, tile.z, this.size * this.GameObject.camera.size);
    
              let src = tileData.src;
              if (tileData.animation) {
                const t = Date.now() % tileData.animation.duration * tileData.animation.textures.length;
                for (let ii in tileData.animation.textures) {
                  ii = Number(ii);
                  const interval = (ii + 1) * tileData.animation.duration;
                  if (t <= interval && t > interval - tileData.animation.duration) {
                    src = tileData.animation.textures[ii];
                    break;
                  }
                }
              }
        
              this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, this.size * this.GameObject.camera.size, this.size * this.GameObject.camera.size);
            }
          }

          for (let eID in this.objects) {
            const object = this.objects[eID];
            if (Math.round(object.x) == rX && Math.round(object.y) == rY && Math.round(object.z) == rZ) {
              // OBJ
              let objectData;
              if (IsometricGame.Map.defaultObjects[object.oid]) { // TODO: Dodać własne elementy od twórcy mapy
                objectData = IsometricGame.Map.defaultObjects[object.oid];
              }
              const screenPosition = this.GameObject.getScreenPositionFromObject(object.x, object.y, object.z, this.size * this.GameObject.camera.size);
        
              let src = objectData.src;
              if (objectData.animation) {
                const t = Date.now() % objectData.animation.duration * objectData.animation.textures.length;
                for (let ii in objectData.animation.textures) {
                  ii = Number(ii);
                  const interval = (ii + 1) * objectData.animation.duration;
                  if (t <= interval && t > interval - objectData.animation.duration) {
                    src = objectData.animation.textures[ii];
                    break;
                  }
                }
              }
        
              this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, this.size * this.GameObject.camera.size, this.size * this.GameObject.camera.size);
            }
          }
        }
      }
    }
  }

  draw_old() {
    const elements = [ ...this.tiles, ...this.objects ];
    const layers = [];
    for (let i in elements) {
      const element = elements[i];
      if (!layers[element.z]) layers[element.z] = {};
      if (typeof element.tid !== 'undefined') {
        if (!layers[element.z].tiles) layers[element.z].tiles = [];
        layers[element.z].tiles.push(element);
      } else if (typeof element.oid !== 'undefined') {
        if (!layers[element.z].objects) layers[element.z].objects = [];
        layers[element.z].objects.push(element);
      }
    }

    for (let layerID in layers) {
      const layer = layers[layerID];
      for(let tileID in layer.tiles) { // draw tiles
        const tile = layer.tiles[tileID];

        if (Math.abs((tile.x + tile.y) / 2 + this.GameObject.camera.y / (this.size * this.GameObject.camera.size) * 2) < this.GameObject.renderDistance && Math.abs((tile.x - tile.y) / 2 + this.GameObject.camera.x / (this.size * this.GameObject.camera.size)) < this.GameObject.renderDistance) {
          let tileData;
          if (IsometricGame.Map.defaultTiles[tile.tid]) { // TODO: Dodać własne elementy od twórcy mapy
            tileData = IsometricGame.Map.defaultTiles[tile.tid];
          }
          const screenPosition = this.GameObject.getScreenPositionFromTile(tile.x, tile.y, tile.z, this.size * this.GameObject.camera.size);
    
          let src = tileData.src;
          if (tileData.animation) {
            const t = Date.now() % tileData.animation.duration * tileData.animation.textures.length;
            for (let ii in tileData.animation.textures) {
              ii = Number(ii);
              const interval = (ii + 1) * tileData.animation.duration;
              if (t <= interval && t > interval - tileData.animation.duration) {
                src = tileData.animation.textures[ii];
                break;
              }
            }
          }
    
          this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, this.size * this.GameObject.camera.size, this.size * this.GameObject.camera.size);
        }
      }
      for(let objectID in layer.objects) { // draw tiles
        const object = layer.objects[objectID];



        if (Math.abs((object.x + object.y) / 2 + this.GameObject.camera.y / (this.size * this.GameObject.camera.size) * 2) < this.GameObject.renderDistance && Math.abs((object.x - object.y) / 2 + this.GameObject.camera.x / (this.size * this.GameObject.camera.size)) < this.GameObject.renderDistance) {
          let objectData;
          if (IsometricGame.Map.defaultObjects[object.oid]) { // TODO: Dodać własne elementy od twórcy mapy
            objectData = IsometricGame.Map.defaultObjects[object.oid];
          }
          const screenPosition = this.GameObject.getScreenPositionFromObject(object.x, object.y, object.z, this.size * this.GameObject.camera.size);
    
          let src = objectData.src;
          if (objectData.animation) {
            const t = Date.now() % objectData.animation.duration * objectData.animation.textures.length;
            for (let ii in objectData.animation.textures) {
              ii = Number(ii);
              const interval = (ii + 1) * objectData.animation.duration;
              if (t <= interval && t > interval - objectData.animation.duration) {
                src = objectData.animation.textures[ii];
                break;
              }
            }
          }
    
          this.GameObject.drawImage(src, screenPosition.x, screenPosition.y, this.size * this.GameObject.camera.size, this.size * this.GameObject.camera.size);
        }



      }
    }

    for (let i in this.tiles) {
      const tile = this.tiles[i];

    }
  }
}

IsometricGame.Map.defaultObjects = {
  // 0: {
  //   name: 'Sprite',
  //   src: 'src/img/tex/sprite.png',
  //   collidable: true,
  //   physics: true,
  // },

  0: {
    name: 'Container',
    src: 'src/img/tex/container.png',
    collidable: true,
    xSize: 3,
    ySize: 2,
    zSize: 2,
    animation: {
      duration: 1200, //ms
      textures: [
        'src/img/tex/container.png',
        'src/img/tex/container2.png',
      ],
    },
  },
  1: {
    name: 'Container',
    src: 'src/img/tex/greenbox.png',
    collidable: true,
    xSize: 2,
    ySize: 2,
    zSize: 2,
    animation: {
      duration: 500, //ms
      textures: [
        'src/img/tex/123.png',
        'src/img/tex/redbox.png',
      ],
    },
  },
  2: {
    name: 'Container',
    src: 'src/img/tex/stone.png',
    collidable: true,
    xSize: 1,
    ySize: 1,
    zSize: 1,
  },
};

IsometricGame.Map.defaultTiles = {
  '-1': {
    name: 'Tile Selector',
    src: 'src/img/tex/tile_select.png',
    animation: {
      duration: 1200, //ms
      textures: [
        'src/img/tex/tile_select.png',
        'src/img/tex/tile_select2.png',
      ],
    },
    collidable: false,
  },
  0: {
    name: 'Grass',
    src: 'src/img/tex/grass.png',
    animation: {
      duration: 1200, //ms
      textures: [
        'src/img/tex/grass.png',
        'src/img/tex/grass2.png',
      ],
    },
    collidable: true,
  },
  1: {
    name: 'Stone',
    src: 'src/img/tex/stone.png',
    collidable: true,
  },
  2: {
    name: 'Water',
    src: 'src/img/tex/water.png',
    animation: {
      duration: 1000, //ms
      textures: [
        'src/img/tex/water.png',
        'src/img/tex/water2.png',
      ],
    },
    collidable: false,
  },
  3: {
    name: 'Box',
    src: 'src/img/tex/whitebox.png',
    animation: {
      duration: 1000, //ms
      textures: [
        'src/img/tex/whitebox.png',
        'src/img/tex/greenbox.png',
      ],
    },
    collidable: false,
  },
}